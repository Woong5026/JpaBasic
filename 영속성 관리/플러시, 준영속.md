### 플러시

플러시(flush)는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다. 플러시를 실행하면 구체적으로 다음과 같은 일이 일어난다.

* 변경 감지 - 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
* 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.

<br/><br/>

영속성 컨텍스트를 플러시하는 방법은 다음과 같다.
* em.flush() - 보통 트랜잭션 커밋을 많이 사용하지만 자체 테스트용으로 flush를 사용할 때가 있다.
* 트랜잭션 커밋 - 플러시가 자동 호출된다.
* JPQL 쿼리 실행 - 플러시가 쿼리 실행 이전에 호출된다.

<br/>

일반적으로 commit후 db에 쿼리가 나가는 반면에 flush는 commit전 db에 쿼리를 강제로 호출하는 것

![image](https://user-images.githubusercontent.com/78454649/203839855-e4a067d9-ec76-4c32-8513-e507e10b083b.png)

위를 보면 commit전에 insert쿼리가 먼저 나가는 것을 볼 수 있다



<br/>


+) 참고로 플러시를 영속성 컨텍스트의 엔티티들을 지우는 것이라 착각하면 안 된다. <br/>
플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화 하는 것이다.(단, 쓰기 지연 저장소는 비워진다.)  <br/>
그리고 데이터베이스와 동기화를 최대한 늦추는 것이 가능한 이유는 트랜잭션이라는 작업 단위가 있기 때문이다. <br/>
트랜잭션 커밋 직전에만 변경 내용을 데이터베이스에 동기화하면 된다.

<br/><br/>

JPQL의 경우 DB에 직접 접근해야 하기 때문에 이전에 쓰기 지연 SQL 저장소의 쿼리를 비워준다.

```java

em.persist(memberA);
em.persist(memberB);
em.persist(memberC);
//중간에 JPQL 실행
query = em.createQuery("select m from Member m", Member.class);
List<Member> members= query.getResultList();

```

예를 들어 위와 같은 코드에서 memberA, memberB, memberC를 영속성 컨텍스트에 저장하고 insert 쿼리를 쓰기 지연 sQL 저장소에 <br/>
저장한 상태일 때, 멤버 클래스 전체를 불러오는 JPQL을 사용한다면 현재 DB에는 멤버 객체들이 없기 때문에 아무것도 불러올 수가 없다. <br/>
JPA는 이런 현상을 방지하고자 JPQL실행 시 무조건 flush를 날려버리고 그 후에 조회, 결과적으로 멤버 A,B,C는 조회가 된다 <br/>
따라서, JPQL 이전에 쓰기 지연 저장소의 insert 쿼리를 미리 DB에 반영해서 원하는 데이터를 얻을 수 있다. 

<br/>

### 준영속 상태

영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된(detached) 것을 준영속 상태라 한다.  <br/>
따라서 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 있다. 영속상태의 엔티티를 준영속 상태로 만드는 방법은 다음과 같다. <br/>

em.detach(entity) - 특정 엔티티를 준영속 상태로 만든다. 메서드를 호출하는 순간 1차 캐시부터 쓰기 지연 SQL 저장소까지 해당 엔티티를 관리하기 위한 모든 정보가 제거된다.<br/>
em.clear() - 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만든다.<br/>
em.close() - 영속성 컨텍스트를 종료한다.<br/>

<br/><br/>

그럼 준영속 상태인 엔티티는 어떻게 되는 걸까?
<br/>
* 영속성 컨텍스트가 제공하는 어떠한 기능도 사용할 수 없기 때문에 비영속 상태에 가깝다.
* 준영속 상태는 이미 한 번 영속 상태였으므로 식별자 값을 가지고 있다.
* 지연 로딩을 사용할 수 없다.(해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법)

### 병합 merge

준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 병합을 사용하면 된다. <br/>
merge() 메서드는 준영속 상태의 엔티티를 받아서 그 정보로 새로운 영속 상태의 엔티티를 반환한다. 

merge의 동작 방식은 다음과 같다.

<br/><br/>

```java
Member mergeMember = em.merge(member);

```

1. merge()를 실행한다.
2. 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티를 조회한다. 만약 1차 캐시에 엔티티가 없으면 DB에서 엔티티를 조회하고 1차 캐시에 저장한다.
3. 조회한 영속 엔티티에(mergeMember) 준영속 엔티티(member)의 값을 채워 넣는다.
4. 해당 영속 엔티티를 반환한다.

<br/><br/>

이제 새로운 영속 상태인 mergeMember가 반환되었기 때문에 준영속 상태인 member는 사용할 필요가 없다. <br/>
따라서 다음과 같이 준영속 엔티티를 참조하던 변수를 영속 엔티티를 참조하도록 변경하는 것이 안전하다.

```java
member = em.merge(member);

```

---

### 정리

1. 엔티티 매니저 팩토리는 엔티티 매니저를 생성하고 그 내부에 영속성 컨텍스트도 함께 만들어진다. <br/>
영속성 컨텍스트는 엔티티 매니저를 통해서 접근할 수 있다.
2. 영속성 컨텍스트는 1차 캐시, 동일성 보장, 쓰기 지연, 변경 감지, 지연 로딩 기능을 사용할 수 있다. <br/>
3. 영속성 컨텍스트에 저장된 엔티티는 플러시 시점에 DB에 반영되는데 일반적으로 트랜잭션 커밋 시에 플러시된다. <br/>
4. 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능들을 사용할 수 없다. <br/>
