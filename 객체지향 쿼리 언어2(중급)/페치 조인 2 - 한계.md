### 별칭


페치 조인 대상에는 별칭을 줄 수 없다. 페치 조인은 연관된 것을 모두 끌고온다는 개념이기 때문에 where m.username ="member1' 같이 조건을 주면 안 된다. 

JPA 표준에서는 지원하지 않지만 하이버네이트에서는 별칭을 지원한다. 그

러나 데이터 무결성이 깨지는 등 복잡해지기 때문에 가능하면 페치 조인에 별칭을 사용하지 않는다.

### 둘 이상의 컬렉션 페치 조인

둘 이상의 컬렉션을 페치할 수 없다. 일대다 연관관계의 경우 한 번의 페치 조인으로도 추가 로우가 생기는 것을 위에서 확인할 수 있었다. 

만약 일대다 -> 다대다로 컬렉션 페치 조인을 두 번한다면 추가 로우는 굉장히 많아지고 복잡해질 것이다. 

그래서 JPQL에서 하나의 컬렉션만 페치 조인할 수 있도록 한다.

### 페이징

컬렉션이 아닌 단일 값 연관 필드(일대일, 다대일)들은 페치 조인을 사용해도 페이징 API를 사용할 수 있다. 

그러나 컬렉션을 페치 조인하면 앞서 말했듯이 데이터가 추가되기 때문에 페이징을 사용하면 경고 로그를 남기면서 메모리에서 페이징 처리를 한다.

데이터가 적으면 상관없겠지만 데이터가 많으면 성능 이슈와 메모리 초과 예외가 발생할 수 있어서 위험하다.

* 페이징을 사용하고 싶다면 팀 엔티티만 조회하는 방법이 있다.

그러나, 지연 로딩으로 인해 N+1문제가 발생한다.

@Batchsize를 사용하면 한번 엔티티를 사용할 때(ex. getMembers().add()) 옵션으로 설정한 size만큼 한 번에 조회하기 때문에 성능 향상을 기대할 수 있다.

<br/><br/>

페치 조인은 SQL 한 번으로 연관된 여러 엔티티를 조회할 수 있어서 성능 최적화에 상당히 유용하다. 

하지만 모든 것을 페치 조인으로 해결할 수는 없다. 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적이다. 

여러 테이블을 조회해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 한다면 억지로 페치 조인을 사용하기보다는<br/>
여러 테이블에서 필요한 필드들만 조회해서 DTO로 반환하는 것이 더 효과적일 수 있다.

> 실무에서 글로벌 로딩 전략은 모두 지연 로딩으로 하고 최적화가 필요한 곳은 페치 조인을 적용한다.


