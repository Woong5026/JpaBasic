값 타입을 컬렉션에 담아서 쓰는 것을 말한다.

연관관계 매핑에서 엔티티를 컬렉션으로 사용하는 것이 아니라 값 타입을 컬렉션에 쓰는 것이다.

값 타입 컬렉션은 값 타입을 하나 이상 저장할 때 사용한다.


관계형 DB는 컬렉션의 값을 넣을 수 없다

![image](https://user-images.githubusercontent.com/78454649/153404664-d79a174a-7745-4255-9b5e-5ae059637600.png)

```java

    @Embedded
    private Address homeAddress;

    @ElementCollection
    @CollectionTable(name = "FAVORATE_FOOD", joinColumns = @JoinColumn(name = "MEMBER_ID"))
    @Column(name = "FOOD_NAME") // 값이 string 하나이니 네임 생성
    private Set<String> favorateFood = new HashSet<>();

    @ElementCollection
    @CollectionTable(name = "ADDRESS", joinColumns = @JoinColumn(name = "MEMBER_ID"))
    private List<Address> addressHistory = new ArrayList<>();

```

생성 테이블

```java

    create table FAVORATE_FOOD (
       MEMBER_ID bigint not null,
        FOOD_NAME varchar(255)
    )
    
    create table ADDRESS (
       MEMBER_ID bigint not null,
        city varchar(255),
        street varchar(255),
        zipcode varchar(255)
    )
    
    // 물론 member에도 Address정보가 추가되었다

```

### 값 타입 컬렉션

• 값 타입을 하나 이상 저장할 때 사용

• @ElementCollection, @CollectionTable 사용

• 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다. 

• 컬렉션을 저장하기 위한 별도의 테이블이 필요함

### 값 타입 컬렉션 사용

```java

            Member member = new Member();
            member.setUsername("member1");
            member.setHomeAddress(new Address("home city", "street","10000"));

            //
            member.getFavorateFood().add("치킨");
            member.getFavorateFood().add("족발");
            member.getFavorateFood().add("피자");

            member.getAddressHistory().add(new Address("old1", "street","10000"));
            member.getAddressHistory().add(new Address("old2", "street","10000"));

            em.persist(member);

```

![image](https://user-images.githubusercontent.com/78454649/153407063-0e971cea-f48b-4164-aa45-d86c72210ff3.png)

먼저 Member가 저장되고 값 타입 컬렉션을 저장하는 별도의 테이블에 대한 INSERT Query가 6개 나갔다.
* 값 타입 컬렉션(다른 테이블)에 대한 persist를 하지 않았는데 쿼리가 나갔다.
* 즉, Member 객체의 라이프 사이클과 동일하게 적용되었다.

Why?
* 값 타입이기 때문이다.
* Member에 소속된 값 타입들의 라이프 사이클은 Member에 의존한다. (별도의 생명주기가 없음)
* 즉, 값 타입은 별도로 persist 또는 update를 할 필요가 없이 Member에서 값을 변경만 하면 자동으로 처리해준다.
* 1:N 연관 관계에서 Cascade=ALL로 설정하고, orphanRemoval=true 로 설정한 것과 유사하다.


### 컬렉션 값 타입 조회

```java

    // ... 위와 동일한 코드 

    em.flush();
    em.clear();

    System.out.println("============ START ============");
    Member findMember = em.find(Member.class, member.getId());
    // em.persist(member);

    tx.commit();
 
```

em.flush(), em.clear()로 영속성 컨텍스트를 비운 후 Member를 조회한다.

- 결과
Member에 소속된 Embedded 타입의 Address 속성은 모두 같이 조회된다.

그러나 컬렉션들은 조회 되지 않는다.

즉, 컬렉션 값 타입들은 지연 로딩(Lazy Loading) 전략을 취한다.

```java

      System.out.println("============ START ============");
      Member findMember = em.find(Member.class, member.getId());
      // 
      List<Address> addressHistory = findMember.getAddressHistory();
      for (Address address : addressHistory) {
          System.out.println("address = " + address.getCity()); //address = old1, address = old2
      }
      // 
      Set<String> favoriteFoods = findMember.getFavoriteFoods();
      for (String favoriteFood : favoriteFoods) {
          System.out.println("favoriteFood = " + favoriteFood); 
      }


```

Why? @ElementCollection(fetch = LAZY) 어노테이션의 fetch 기본값이 LAZY(프록시) 이다

### 값 타입 수정

* 값 타입 수정에 대한 기본 개념

```java

System.out.println("============ START ============");
  Member findMember = em.find(Member.class, member.getId());

  // homeCity -> newCity 
  // findMember.getHomeAddress().setCity("newCity"); // 틀린 방법 

  Address address = findMember.getHomeAddress();
  findMember.setHomeAddress(new Address("newCity", address.getStreet(), address.getZipCode())); // 새로 생성 

  tx.commit();

```
  값 타입은 불변(Immutable)이어야 한다.

  따라서, 수정하고 싶은 임베디드 타입의 속성이 있는 경우 새로운 인스턴스를 생성하여 통으로 갈아 끼워야 한다.

1. 컬렉션 값 타입 수정 예시1 - Set<String> 수정

```java
  
  System.out.println("============ START ============");
 Member findMember = em.find(Member.class, member.getId());
 // 치킨 -> 한식 
 findMember.getFavoriteFoods().remove("치킨");
 findMember.getFavoriteFoods().add("한식");

  
```
  
String은 불변 객체 이므로 삭제하고, 다시 리스트에 넣어준다.
  
String 자체가 값 타입이므로 업데이트를 할 수가 없다. 위와 마찬가지로 통으로 갈아 끼워야 한다.
  
컬렉션의 값만 변경해도 JPA가 변경 사항을 알아 내서 실제 DB에 Query를 날린다.(영속성 전이가 되는 것처럼)
  
컬렉션은 Member 소속의 단순한 값이기 때문에 Member에 모든 생명 주기를 맡긴다.

  
2. 컬렉션 값 타입 수정 예시2 - List<Address> 수정

```java
  
 System.out.println("============ START ============");
 Member findMember = em.find(Member.class, member.getId());
 // old1 -> newCity1
 findMember.getAddressHistory().remove(new Address("old1", "street1", "10001")); // equals 로 비교 (값이 정확해야지만 제거)
 findMember.getAddressHistory().add(new Address("newCity1", "street1", "10001"));

```  

equals(), hashCode() 에 대한 제대로 된 재정의가 필요하다.
  
AddressHistory 테이블에서 Member 에 소속된 Address 를 모두 지운다.
  * 먼저 기존 id에 해당하는 테이블을 모두 지운 후 기존에 작성되었던 old2와 newCity1를 두번 insert를 날린다, 한 마디로 모두 갈아끼운다고 생각하면된다
  * 테이블에 있는 데이터를 갈아 끼운다.
  * old2, newCity1 에 대한 Address 를 새로 INSERT 한다.


### 컬렉션 값 타입 조회
  
