멤버<->팀이 연관되어 있을 때, 멤버 엔티티를 조회할 때 팀 엔티티도 함께 조회하는 것이 좋을까? <br/>
그것은 상황마다 다를 것이다. JPA는 개발자가 연관된 엔티티의 조회 시점을 선택할 수 있도록 즉시 로딩과 지연 로딩 두 가지 방법을 제공한다.



member.java

```java

    @ManyToOne(fetch = FetchType.LAZY) // FetchType.LAZY가 설정되면 프록시 타입으로 변경, 이는 멤버 테이블만 DB에서 조회한다는 뜻
    @JoinColumn
    private Team team;

```

main.java

```java

            Team team = new Team();
            team.setName("taemA");
            em.persist(team);

            Member member = new Member();
            member.setUsername("hello");
            member.setTeam(team);
            em.persist(member);
            
            em.flush();
            em.clear();

            Member findMember = em.find(Member.class, member.getId());
            // 지연로딩을 하면 team을 Team$HibernateProxy$hH1AkAQo 프록시로 가져온다
            // 그리고 그 후 team에 속성을 사용하는 시점에는 프록시객체가 초기화되며 DB에서 값을 가져온다
            System.out.println("findMember = " + findMember.getTeam().getClass()); 

            tx.commit();

```

그렇기에 지연로딩으로 설정하면 연관된 것을 프록시로 가져온다

### 지연로딩(LAZY) 

![image](https://user-images.githubusercontent.com/78454649/153334327-d3193841-20da-41b8-85ae-e984447a4584.png)

지연 로딩 LAZY을 사용해서 프록시로 조회

멤버 클래스의 team fetch 타입을 LAZY로 설정했다면 그림과 같이 team 멤버 변수에 프록시 객체를 넣어둔다.<br/>
이 프록시 객체는 실제 사용될 때까지 데이터 로딩을 미룬다.

<br/>

![image](https://user-images.githubusercontent.com/78454649/153334405-3f1790f9-4915-491f-92fe-f5fafe70f969.png)

team에 있는 것을 실제 사용할 때 발생 (getName 등을 호출할 때) <br/>
getTeam()으로 Team을 조회하면 프록시 객체가 조회가 된다. <br/>
getTeam().getXXX()으로 팀의 필드에 접근 할 때, 쿼리가 나간다.

<br/>

```java

public void testEntity() throws Exception{
        // given
        Team teamA = new Team("teamA");
        Team teamB = new Team("teamB");
        em.persist(teamA);
        em.persist(teamB);

        Member member1 = new Member("member1", 10, teamA);
        Member member2 = new Member("member1", 20, teamA);
        Member member3 = new Member("member1", 30, teamB);
        Member member4 = new Member("member1", 40, teamB);

        em.persist(member1);
        em.persist(member2);
        em.persist(member3);
        em.persist(member4);

        // when
        em.flush();
        em.clear();

```

결과값

```java

select
        member0_.member_id as member_i1_0_,
        member0_.age as age2_0_,
        member0_.team_id as team_id4_0_,
        member0_.username as username3_0_ 
    from
        member member0_
        
        member = Member(id=3, username=member1, age=10)
                     : 
    select
        team0_.team_id as team_id1_1_0_,
        team0_.name as name2_1_0_ 
    from
        team team0_ 
    where
        team0_.team_id=?
        
        member.team = Team(id=1, name=teamA)
        member = Member(id=4, username=member2, age=20)
        member.team = Team(id=1, name=teamA)
        
        // proxy로 조회하다 teamB의 teamName이 필요할때 실제 엔티티를 가져오고 그 뒤에는 영속성 컨텍스트에 있는 teamB로 조회
        member = Member(id=5, username=member3, age=30)
        
    select
        team0_.team_id as team_id1_1_0_,
        team0_.name as name2_1_0_ 
    from
        team team0_ 
    where
        team0_.team_id=?

```

위의 코드를 보면 proxy는 실제로 값을 불러올때 초기화가 되는 것을 볼 수 있다.

<br/>

만약 비즈니스 로직이 멤버만 사용하고 팀은 거의 사용 안하는 경우도 있고 필수적으로 같이 사용하는 경우도 있다

필수적으로 같이 사용하는 경우에는 쿼리가 멤버 따로 팀 따로 두 번씩 쿼리문이 생성될 것이다 > 이는 성능상 문제 발생

이때 필요한 것이 즉시로딩


### 즉시로딩(EAGER)

```java
@ManyToOne(fetch = FetchType.**EAGER**)
    @JoinColumn
    private Team team;

```

이렇게 하면 Main에서 조회할때 member와 team을 조인하여 한 번에 쿼리문을 가져온다

한번에 다 가져온 것이기 때문에 프록시가 필요하지 않다, 그렇기에 LAZY와 다르게 팀의 클래스를 조회해보면 프록시가 아닌 진짜가 출력된다


### 프록시와 즉시로딩 주의

가급적 지연 로딩만 사용(특히 실무에서) 

즉시 로딩을 적용하면 예상하지 못한 SQL이 발생 <br/>
@ManyToOne이 5개 있는데 전부 EAGER로 설정되어 있다고 생각해보자. <br/>
조인이 5개 일어난다. 실무에선 테이블이 더 많다.


즉시 로딩일 때, 데이터베이스 입장에서 테이블이 매우 많고 그에 따라 join이 너무 많아지면 조회할 때 부하가 심해진다. <br/>
또한 JPQL에서 문제가 생긴다. 다음 코드를 보자.

```java

List<Member> members = em.createQuery("select m from Member m", Member.class).getResultList();

```

JPQL은 우선 쿼리 내용을 우선적으로 데이터베이스에 보낸다. 그래서 멤버를 select하는데, <br/>
이 때 team 멤버 변수에 fetch 타입이 즉시 로딩으로 되어 있다면 select 쿼리를 한번 더 보내 team을 가져온다. <br/>
이렇게 연관된 객체가 많아지면 그만큼 쿼리를 계속 추가로 보내게되는데 이것을 N+1 문제라고 한다.<br/>
(쿼리가 하나 나가는데 추가 쿼리가 N개 나간다.) 

<br/>


즉시 로딩은 JPQL에서 N+1 문제를 일으킨다. 
> JPQL 생성 시 qlString이 바로 sql로 번역된다 , 그 후 DB에 select * from Member 쿼리가 나가고 Memeber탐색 
> 그 후 멤버를 보니 team도 가져와야 함을 인지, 이 떄 LAZY면 프록시를 넣으면 되는데 진짜를 가져와야 하니 반환할 때 이미 값이 다 들어가 있어야 된다
> DB가 EAGER를 인지 한 순간 SQL이 또 나간다

@ManyToOne, @OneToOne은 기본(디폴트)이 즉시 로딩-> LAZY로 설정

@OneToMany, @ManyToMany는 기본이 지연 로딩

<br/><br/>


즉시 로딩은 JPQL에서 N+1 문제를 일으킨다. <br/>
실무에서 복잡한 쿼리를 많이 풀어내기 위해서 뒤에서 학습할 JPQL을 많이 사용한다.<br/>
em.find()는 PK를 정해놓고 DB에서 가져오기 때문에 JPA 내부에서 최적화를 할 수 있다.(한방 쿼리)

하지만, JPQL에선 입력 받은 query string이 그대로 SQL로 변환된다. <br/>
"select m from Member m" 이 문장으로 당연히 Member만 SELECT 하게 된다. <br/>
MEMBER를 쭉 다 가져와서 보니까

어 근데, Member 엔티티의 Team의 fetchType이 EAGER네? <br/>
LAZY면 프록시를 넣으면 되겠지만, EAGER는 반환하는 시점에 다 조회가 되어 있어야 한다. <br/>
따라서, Member를 다 가져오고 나서, 그 Member와 연관된 Team을 다시 다 가져온다.

코드로 이해하기

멤버가 2명이고, 팀도 2개다. 각각 다른 팀이다. <br/>
모든 멤버를 조회해보자.

```java

Team team1 = new Team();
team1.setName("teamA");
em.persist(team1);

Team team2 = new Team();
team2.setName("teamB");
em.persist(team2);

Member member1 = new Member();
member1.setUsername("memberA");
em.persist(member1);
member1.changeTeam(team1);

Member member2 = new Member();
member2.setUsername("memberB");
em.persist(member2);
member2.changeTeam(team2);

em.flush();
em.clear();

List<Member> members = em
                .createQuery("select m from Member m", Member.class)
  .getResultList();

tx.commit();


```

실행 결과를 보면, <br/>
일단 멤버를 조회해서 가져온다. <br/>
그리고 나서 Member들의 Team이 비어있으니까 채워서 반환시키기 위해서 TEAM을 각각 쿼리 날려서 가져온다.<br/>
-> 실제로 데이터를 조회하는 teamName등이 없지만 연관관계가 있으니 일단 쿼리를 가져오는 것

<br/>

N + 1의 문제의 의미는 <br/>
아래 처럼 쿼리를 1개 날렸는데, 그것 때문에 추가 쿼리가 N개 나간다는 의미이다.

```java

Hibernate: 
    /* select
        m 
    from
        Member m */ select
            member0_.id as id1_4_,
            member0_.createdBy as createdB2_4_,
            member0_.createdDate as createdD3_4_,
            member0_.lastModifiedBy as lastModi4_4_,
            member0_.lastModifiedDate as lastModi5_4_,
            member0_.age as age6_4_,
            member0_.description as descript7_4_,
            member0_.locker_id as locker_10_4_,
            member0_.roleType as roleType8_4_,
            member0_.team_id as team_id11_4_,
            member0_.name as name9_4_ 
        from
            Member member0_
Hibernate: 
    select
        team0_.id as id1_8_0_,
        team0_.createdBy as createdB2_8_0_,
        team0_.createdDate as createdD3_8_0_,
        team0_.lastModifiedBy as lastModi4_8_0_,
        team0_.lastModifiedDate as lastModi5_8_0_,
        team0_.name as name6_8_0_ 
    from
        Team team0_ 
    where
        team0_.id=?
Hibernate: 
    select
        team0_.id as id1_8_0_,
        team0_.createdBy as createdB2_8_0_,
        team0_.createdDate as createdD3_8_0_,
        team0_.lastModifiedBy as lastModi4_8_0_,
        team0_.lastModifiedDate as lastModi5_8_0_,
        team0_.name as name6_8_0_ 
    from
        Team team0_ 
    where
        team0_.id=?


```

근데 실무에서 대부분 멤버 팀을 함께 사용하는 경우가 있는데, 그러면 LAZY로 해놓고 계속 쿼리 두방 날려서 조회 해올까요?

이런 경우를 위해서 JPQL의 fetch join 을 통해서 해당 시점에 한방 쿼리로 가져와서 쓸 수 있다.





